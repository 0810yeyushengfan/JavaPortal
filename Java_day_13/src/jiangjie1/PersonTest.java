package jiangjie1;
/*
面向对象特征之三:多态性
理解多态性:可以理解为一个事物的多种形态。
1.理解多态性:可以理解为一个事物的多种形态。
2.何为多态性:
  对象的多态性:父类的引用指向子类的对象（或子类的对象赋给父类的引用）
3.多态的使用:虚拟方法调用
  有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法，
  总结:编译看左边，运行看右边。
4.多态性的使用前提:
  4.1类的继承关系
  4.2方法的重写
5.对象的多态性:只适用于方法，不适用于属性（属性的编译和运行都看左边）
6.多态是编译时行为还是运行时行为
  多态是典型的运行时行为。
7.方法的重载和重写在编译和运行的角度的区别
  重载:是指允许存在多个同名方法，而这些方法的参数不同，编译器根据方法不同的参数表，对同名方法的名称做修饰。
      对于编译器而言，这些同名方法就成了不同的方法，它们的调用地址在编译期就绑定了，java的重载是可以包括
      父类和子类的，即子类可以重载父类的同名不同参数的方法。
  所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为”早绑定“或”静态绑定“。
  而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为”晚绑定“或者”动态绑定“。
 */
public class PersonTest {
    public static void main(String[] args) {
        Person p1=new Person();
        p1.eat();
        Man man=new Man();
        man.eat();
        man.age=25;
        man.earnMoney();
        System.out.println("*******************");
        //对象的多态性:父类的引用指向子类的对象
        Person p2=new Man();
        Person p3= new Woman();
        //多态的使用:当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法---虚拟方法调用
        p2.eat();
        p2.walk();
        //p2.earnMoney();无法调用父类中不存在而子类中特有的方法
        System.out.println(p2.id);//1001
    }
}
